"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Student = void 0;
const Account_1 = require("./Account");
const types_1 = require("../types");
const functions_1 = require("../functions");
const textbook_1 = require("../functions/student/textbook");
const mailbox_1 = require("../functions/student/mailbox");
const timelines_1 = require("../functions/student/timelines");
class Student extends Account_1.Account {
    constructor(session) {
        super(session);
        this.session = session;
        this.type = "student";
        const mainAccount = functions_1.getMainAccount(session.loginRes.data.accounts);
        if (!types_1.isStudentAccount(mainAccount))
            throw new Error("Family class's main account is wrong");
        if (!session.token)
            throw new Error("Account class MUST have token");
        this.account = mainAccount;
        this.token = session.token;
    }
    /**
     * Fetches the homework
     * @param dates (Array of) variable(s) which can be converted into Date object(s)
     * @param onlyWithWork If true, will ignore all assignements objects that do not contain any homework
     */
    async getHomework(params = {}) {
        let { dates } = params;
        const { onlyWithWork } = params;
        if (!dates) {
            const upcomingAssignementDates = await textbook_1.getUpcomingAssignementDates(this.account.id, this.token);
            dates = upcomingAssignementDates.dates;
            this.token = upcomingAssignementDates.token;
        }
        if (!Array.isArray(dates))
            dates = [dates];
        const resultsArray = (await Promise.all(dates.map(async (date) => {
            const d = functions_1.toISODate(date);
            const textbook = await functions_1.getTextbookPage(this.account.id, this.token, d);
            this.token = textbook.token;
            const homework = textbook.data;
            const cleaned = functions_1.cleanAssignements(homework, this);
            if (onlyWithWork)
                return cleaned.filter(v => !!("job" in v));
            return cleaned;
        })))
            .flat()
            .sort((a, b) => a.date.getTime() - b.date.getTime());
        return resultsArray;
    }
    /**
     * @returns Every sent and received message, in ascending order by id
     */
    async getMessages() {
        const received = await functions_1.getMessages(this.account.id, this.token, "received");
        this.token = received.token;
        const sent = await functions_1.getMessages(this.account.id, this.token, "sent");
        this.token = sent.token;
        const messages = received;
        messages.data.messages.sent = sent.data.messages.sent;
        const cleaned = mailbox_1.cleanMessages(messages, this);
        return cleaned;
    }
    /**
     * @returns Every grade
     */
    async getGrades() {
        const _grades = await functions_1.getGrades(this.account.id, this.token);
        this.token = _grades.token;
        const grades = functions_1.cleanGrades(_grades.data.notes);
        return grades;
    }
    /**
     * @returns Every periods with their subjects. Useful to get more infos about grades.
     * It is recommended to cache them.
     */
    async getPeriods() {
        const _grades = await functions_1.getGrades(this.account.id, this.token);
        this.token = _grades.token;
        const periods = functions_1.cleanPeriods(_grades.data.periodes);
        return periods;
    }
    async timeline() {
        const _timeline = await functions_1.getTimeline(this.account.id, this.token);
        this.token = _timeline.token;
        const tlElems = timelines_1.cleanStudTimeline(_timeline);
        return tlElems;
    }
    async getPhoto() {
        const buf = await functions_1.fetchPhoto(this._raw);
        return buf;
    }
    get _raw() {
        return this.account;
    }
}
exports.Student = Student;

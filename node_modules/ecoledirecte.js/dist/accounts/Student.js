"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Student = void 0;
const Account_1 = require("./Account");
const v3_1 = require("ecoledirecte-api-types/v3");
const functions_1 = require("../functions");
const classes_1 = require("../classes");
const classes_2 = require("../classes");
const textbook_1 = require("../functions/student/textbook");
const mailbox_1 = require("../functions/student/mailbox");
class Student extends Account_1.Account {
    constructor(session) {
        super(session);
        this.session = session;
        this.type = "student";
        const mainAccount = functions_1.getMainAccount(session.loginRes.data.accounts);
        if (!v3_1.isStudentAccount(mainAccount))
            throw new Error("Family class's main account is wrong");
        if (!session.token)
            throw new Error("Account class MUST have token");
        this.account = mainAccount;
        this.token = session.token;
    }
    /**
     * Fetches the homework
     * @param dates (Array of) variable(s) which can be converted into Date object(s). Preffered type: "YYYY-MM-DD"
     * @param onlyWithWork If true, will ignore all assignements objects that do not contain any homework
     */
    async getHomework(params = {}, context = {}) {
        let { dates } = params;
        const { onlyWithWork } = params;
        if (!dates) {
            const upcomingAssignementDates = await textbook_1.getUpcomingAssignementDates(this.account.id, this.token, context);
            dates = upcomingAssignementDates.dates;
            this.token = upcomingAssignementDates.token;
        }
        if (!Array.isArray(dates))
            dates = [dates];
        const resultsArray = (await Promise.all(dates.map(async (date) => {
            const d = functions_1.toISODate(date);
            const textbook = await functions_1.getTextbookPage(this.account.id, this.token, d, context);
            this.token = textbook.token;
            const homework = textbook.data;
            const cleaned = homework.matieres.map(s => new classes_2.Assignement(s, homework.date, this));
            if (onlyWithWork)
                return cleaned.filter(v => !!("job" in v));
            return cleaned;
        })))
            .flat()
            .sort((a, b) => a.date.getTime() - b.date.getTime());
        return resultsArray;
    }
    /**
     * @returns Every sent and received message, in ascending order by id
     */
    async getMessages(context = {}) {
        const received = await functions_1.getMessages(this.account.id, this.token, "received", context);
        this.token = received.token;
        const sent = await functions_1.getMessages(this.account.id, this.token, "sent", context);
        this.token = sent.token;
        const messages = received;
        messages.data.messages.sent = sent.data.messages.sent;
        const cleaned = mailbox_1.cleanMessages(messages, this);
        return cleaned;
    }
    /**
     * @returns Every grade
     */
    async getGrades(context = {}) {
        const _grades = await functions_1.getGrades(this.account.id, this.token, context);
        this.token = _grades.token;
        const grades = _grades.data.notes.map(g => new classes_2.Grade(g));
        return grades;
    }
    /**
     * @returns Every periods with their subjects. Useful to get more infos about grades.
     * It is recommended to cache them.
     */
    async getPeriods(context = {}) {
        const _grades = await functions_1.getGrades(this.account.id, this.token, context);
        this.token = _grades.token;
        const periods = _grades.data.periodes.map(p => new classes_2.Period(p));
        return periods;
    }
    /**
     * @returns The equivalent of `getGrades` and `getPeriods`, with only 1 request
     */
    async getGradesAndPeriods(context = {}) {
        const _all = await functions_1.getGrades(this.account.id, this.token, context);
        this.token = _all.token;
        const grades = _all.data.notes.map(g => new classes_2.Grade(g));
        const periods = _all.data.periodes.map(p => new classes_2.Period(p));
        return { grades, periods };
    }
    async timeline(context = {}) {
        const _timeline = await functions_1.getTimeline(this.account.id, this.token, context);
        this.token = _timeline.token;
        const tlElems = _timeline.data
            ? _timeline.data.map(e => new classes_1.TimelineElem(e))
            : [];
        return tlElems;
    }
    async getPhoto() {
        const r = await functions_1.fetchPhoto(this._raw);
        if (!r)
            return;
        const [buf, str] = r;
        this._photo = buf;
        this._photoUri = str;
        return buf;
    }
    get photo() {
        return {
            buffer: this._photo,
            uri: this._photoUri,
        };
    }
    get _raw() {
        return this.account;
    }
}
exports.Student = Student;
